class BoutGenerator:
    """ Bout generator with motor inhibition of bout initiation.

    Bout initiation is determined by a poisson process whose rate is proportional to the rate input but inhibited by
    recent motor activity.

    The motor signal is generated by an linear time-invariant system whose response function generates a swim bout
    with the observed intensity profile for each input impulse. The amplitude of the input impulses, and therefore
    the scale of the motor output, is proportional to the intensity input at the time the bout is initiated.

    If k_motor is not otherwise configured it defaults to zero so the bout generator operates without motor inhibition

    If the input u to the select_action method is scalar this implements the basic bout generator with single input
    driving both bout initiation and intensity

    If the input to the  select_action method is a pair this implements the dual process bout generator with
    first element the rate input and second the intensity input.
    """

    def __init__(self, dt, rgen, **_cfg):
        self.dt = dt
        self.rgen = rgen  # random number generator
        self.motor_output = 0.0  # intensity of a swimming bout (i.e. motor_output)
        self.start_bout = False  # whether a new bout started in this timestep
        self.bout_step = 0
        self.motori = 0.0  # output of motor integrator
        self.m_rate = 0.0  # inhibitory contribution of motor integration on start rate
        self.start_rate = 0.0  # poisson rate for bout initiation
        self.impulse = 0.0  # scaled impulse sent to the profile generator
        self.intensity_scale = 0.0  # current intensity scale signal
        self.krate = None
        self.kintensity = None
        self.kmotor = None
        self.tau_motor = None
        self.bout_profile = None
        self.scale = None
        self.bout_refactory_period = None
        self.duration_so_far = None

    def configure(self, bout_profile, bout_refactory_period, k_rate=1.0, k_intensity=1.0, k_motor=0.0, tau_motor=0.0,
                  **_cfg):
        self.krate = k_rate  # proportionality constant for rate input
        self.kintensity = k_intensity  # proportionality constant for intensity input
        self.kmotor = k_motor  # gain for motor integration contribution to poisson rate
        self.tau_motor = tau_motor  # time constant for leaky motor integration
        # observed average bout speed profile in 10ms time steps normalised for mean speed of 1mm/s
        self.bout_profile = bout_profile
        self.scale = 0.0  # intensity scale factor for the current bout

        # minimum time between bouts
        self.bout_refactory_period = bout_refactory_period

        # how long bout or interbout has lasted so far, initialised so that a bout could start immediately
        self.duration_so_far = bout_refactory_period

    def select_action(self, u):
        """
        """
        # for scalar input u_rate and u_intensity are the same, otherwise
        # specified separately as a tuple
        if isinstance(u, tuple):
            u_rate, u_intensity = u
        else:
            u_rate = u_intensity = u

        # update the motor integrator
        if self.tau_motor <= self.dt:
            self.motori = self.motor_output
        else:
            self.motori += self.dt * (self.motor_output - self.motori / self.tau_motor)
        self.m_rate = -self.kmotor * self.motori

        self.start_rate = self.krate * (u_rate + self.m_rate)

        self.intensity_scale = self.kintensity * u_intensity

        # a new bout starts if start rate is positive and we are past the refactory period,
        # with probability depending on the start rate
        self.start_bout = (self.start_rate > 0 and self.duration_so_far >= self.bout_refactory_period and
                           self.start_rate * self.dt > self.rgen.uniform(0, 1))

        # set the speed scale factor and start a new refactory period when a bout starts
        if self.start_bout:
            self.bout_step = 0
            self.duration_so_far = self.dt / 2

            # mean scale factor for speed profile is a linear function of the normalised intensity
            # input at the start of the bout
            self.scale = max(0, self.intensity_scale)

        self.impulse = self.scale * self.start_bout

        self.motor_output = self.bout_profile[self.bout_step] * self.scale if self.bout_step < len(
            self.bout_profile) else 0

        self.duration_so_far += self.dt
        self.bout_step += 1

        return self.motor_output

    def record(self, rec):
        rec['motor_output'] = self.motor_output
        rec['k_rate'] = self.krate
        rec['k_intensity'] = self.kintensity
        rec['k_motor'] = self.kmotor
        rec['tau_motor'] = self.tau_motor
        rec['motor_integral'] = self.motori
        rec['m_rate'] = self.m_rate
        rec['start_rate'] = self.start_rate
        rec['bout_scale'] = self.scale
        rec['intensity_scale'] = self.intensity_scale
        rec['start_bout'] = self.start_bout
        rec['scaled_impulse'] = self.impulse

    def __str__(self):
        return (f'{type(self).__name__}: '
                f'\n   k_rate {self.krate} k_intensity {self.kintensity}'
                f'\n   tau_motor {self.tau_motor}  k_motor {self.kmotor}'
                f'\n   refactory period {self.bout_refactory_period}'
                )
